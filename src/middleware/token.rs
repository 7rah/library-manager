use crate::auth::verify_token;
use crate::db::user::{query, Status};
use crate::error::Error;
use log::debug;
use poem::{Endpoint, IntoResponse, Middleware, Request, Response, Result};
/// A middleware that extract token from HTTP headers.
pub struct TokenMiddleware;

impl<E: Endpoint> Middleware<E> for TokenMiddleware {
    type Output = TokenMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        TokenMiddlewareImpl { ep }
    }
}

/// The new endpoint type generated by the TokenMiddleware.
pub struct TokenMiddlewareImpl<E> {
    ep: E,
}

const TOKEN_HEADER: &str = "X-Token";

#[poem::async_trait]
impl<E: Endpoint> Endpoint for TokenMiddlewareImpl<E> {
    type Output = Response;

    async fn call(&self, mut req: Request) -> Result<Self::Output> {
        if let Some(value) = req
            .headers()
            .get(TOKEN_HEADER)
            .and_then(|value| value.to_str().ok())
        {
            // Insert token data to extensions of request.
            let token = value.to_string();
            let token = verify_token(token);
            debug!("Token: {token:?}");
            if let Some(token) = token {
                if let Some(user) = query(&token.email).await {
                    if user.status.ne(&Status::Disabled) {
                        req.extensions_mut().insert(token);
                    } else {
                        return Ok(Error::AccountWasDisabled.to_string().into_response());
                    }
                }
            } else {
                return Ok(Error::InvalidlToken.to_string().into_response());
            }
        }

        // call the inner endpoint.
        self.ep.call(req).await.map(IntoResponse::into_response)
    }
}
